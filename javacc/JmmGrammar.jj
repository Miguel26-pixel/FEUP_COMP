PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP :
    < SPACE : " " >
    | < TAB : "\t" >
    | < CARRIAGE_RETURN: "\r" >
    | < LINE_FEED: "\n" >
    | < SINGLE_LINE_COMMENT: "//" (~["\r", "\n"])* >
    | < MULTI_LINE_COMMENT: "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >
;

TOKEN :
	< PLUS : "+" >
	| < MINUS : "-" >
	| < TIMES : "*" >
	| < DIVIDE : "/" >
    | < EQUAL : "=" >
	| < AND: "&&" >
	| < OR: "||" >
	| < LESS_THAN: "<" >
	| < NOT: "!" >
	| < OPEN_PARENTHESES : "(" >
	| < CLOSE_PARENTHESES : ")" >
	| < OPEN_CURLY_BRACKETS : "{" >
    | < CLOSE_CURLY_BRACKETS : "}" >
	| < OPEN_SQUARE_BRACKETS : "[" >
    | < CLOSE_SQUARE_BRACKETS : "]" >
	| < SEMICOLON : ";" >
	| < DOT : "." >
	| < COMMA : "," >
	| < IMPORT : "import" >
    | < CLASS : "class" >
    | < EXTENDS : "extends" >
    | < PUBLIC : "public" >
    | < STATIC : "static" >
    | < VOID : "void" >
    | < MAIN : "main" >
    | < THIS : "this" >
    | < NEW : "new" >
    | < STRING : "String" >
    | < BOOLEAN : "boolean" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < INT : "int" >
    | < IF : "if" >
    | < ELSE : "else" >
    | < WHILE : "while" >
    | < LENGTH : "length" >
    | < RETURN : "return" >
    | < ID : ["A"-"Z","a"-"z","$","_"](["A"-"Z","a"-"z","0"-"9","$","_"])* >
    | < INTEGER : (["0" - "9"])+ >
;

Start:
    (ImportDeclaration)* ClassDeclaration <EOF>
;

ImportDeclaration:
    < IMPORT > < ID >  (< DOT > < ID >)* < SEMICOLON >
;

ClassDeclaration:
    < CLASS > < ID > (< EXTENDS > < ID >)? < OPEN_CURLY_BRACKETS > (VarDeclaration | MethodDeclaration)* < CLOSE_CURLY_BRACKETS >
;

VarDeclaration:
    Type < ID > (< EQUAL > Expression)? < SEMICOLON >
;

MethodDeclaration:
    <PUBLIC> (MainMethod | RegularMethod)
;

RegularMethod:
    Type < ID > < OPEN_PARENTHESES > (Type < ID > (< COMMA > Type < ID >)* #Arguments)? < CLOSE_PARENTHESES >
    < OPEN_CURLY_BRACKETS >
        ( SCAN 2 VarDeclaration | Statement )*
        < RETURN > Expression < SEMICOLON >
    < CLOSE_CURLY_BRACKETS >
;

MainMethod:
    < STATIC > < VOID > < MAIN > < OPEN_PARENTHESES > < STRING > < OPEN_SQUARE_BRACKETS > < CLOSE_SQUARE_BRACKETS > < ID > < CLOSE_PARENTHESES >
    < OPEN_CURLY_BRACKETS>
        ( SCAN 2 VarDeclaration | Statement )*
    < CLOSE_CURLY_BRACKETS >
;

Type:
    < INT > (< OPEN_SQUARE_BRACKETS > < CLOSE_SQUARE_BRACKETS >)?
    | < BOOLEAN >
    | < ID >
;

Statement #void:
    (SCAN 2
        < ID > (
                < EQUAL > Expression < SEMICOLON > #VariableAssignment
                | < OPEN_SQUARE_BRACKETS > Expression < CLOSE_SQUARE_BRACKETS > < EQUAL > Expression < SEMICOLON > #ArrayAssignment
               )
        | Expression < SEMICOLON >
    )
    | < IF > < OPEN_PARENTHESES > Expression < CLOSE_PARENTHESES > Statement < ELSE > Statement #If
    | < WHILE > <OPEN_PARENTHESES > Expression < CLOSE_PARENTHESES > Statement #While
    | < OPEN_CURLY_BRACKETS > (Statement)* < CLOSE_CURLY_BRACKETS >
;

Expression #void:
    OrExpression
;

OrExpression #void:
    AndExpression (<OR> ({ jjtThis.put("op", "or"); }) #BinOp(2) AndExpression)*
;

AndExpression #void:
    RelationalExpression (<AND> ({ jjtThis.put("op", "and"); }) #BinOp(2) RelationalExpression)*
;

RelationalExpression #void:
    AddExpression (<LESS_THAN> ({ jjtThis.put("op", "lt"); }) #BinOp(2) AddExpression)?
;

AddExpression #void:
    MultExpression ((
            <PLUS> ({ jjtThis.put("op", "add"); }) #BinOp(2)
            | <MINUS> ({ jjtThis.put("op", "sub"); }) #BinOp(2)
        ) MultExpression)*
;

MultExpression #void:
    NewExpression ((
            <TIMES> ({ jjtThis.put("op", "mul"); }) #BinOp(2)
            | <DIVIDE> ({ jjtThis.put("op", "div"); }) #BinOp(2)
        ) NewExpression)*
;

NewExpression #void:
    < NEW > (
                < INT > < OPEN_SQUARE_BRACKETS > NotExpression < CLOSE_SQUARE_BRACKETS > #NewArray
                | < ID > < OPEN_PARENTHESES > < CLOSE_PARENTHESES > #NewObject
            )
    | NotExpression
;

NotExpression #void:
    (< NOT >)? TerminalExpression
;

TerminalExpression #void:
    (
        < OPEN_PARENTHESES > Expression < CLOSE_PARENTHESES >
        | Terminal
    ) (TerminalExpressionCompound)*
;

TerminalExpressionCompound #void:
    < OPEN_SQUARE_BRACKETS > Expression < CLOSE_SQUARE_BRACKETS > #Indexation
    | < DOT > (< LENGTH > | < ID > < OPEN_PARENTHESES > (Expression (< COMMA > Expression)*)? < CLOSE_PARENTHESES >) #MethodCall
;

Terminal #void:
    < INTEGER >
    | < TRUE >
    | < FALSE >
    | < ID >
    | < THIS >
;

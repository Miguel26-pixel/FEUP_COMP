PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES=false;

SKIP :
    < SPACE : " " >
    | < TAB : "\t" >
    | < CARRIAGE_RETURN: "\r" >
    | < LINE_FEED: "\n" >
    | < SINGLE_LINE_COMMENT: "//" (~["\r", "\n"])* >
    | < MULTI_LINE_COMMENT: "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >
;

TOKEN :
	< PLUS : "+" >
	| < MINUS : "-" >
	| < TIMES : "*" >
	| < DIVIDE : "/" >
    | < EQUAL : "=" >
	| < AND: "&&" >
	| < OR: "||" >
	| < LESS_THAN: "<" >
	| < NOT: "!" >
	| < OPEN_PARENTHESES : "(" >
	| < CLOSE_PARENTHESES : ")" >
	| < OPEN_CURLY_BRACKETS : "{" >
    | < CLOSE_CURLY_BRACKETS : "}" >
	| < OPEN_SQUARE_BRACKETS : "[" >
    | < CLOSE_SQUARE_BRACKETS : "]" >
	| < SEMICOLON : ";" >
	| < DOT : "." >
	| < COMMA : "," >
	| < IMPORT : "import" >
    | < CLASS : "class" >
    | < EXTENDS : "extends" >
    | < PUBLIC : "public" >
    | < STATIC : "static" >
    | < VOID : "void" >
    | < MAIN : "main" >
    | < THIS : "this" >
    | < NEW : "new" >
    | < BOOLEAN : "boolean" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < INT : "int" >
    | < IF : "if" >
    | < ELSE : "else" >
    | < WHILE : "while" >
    | < LENGTH : "length" >
    | < RETURN : "return" >
    | < ID : ["A"-"Z","a"-"z","$","_"](["A"-"Z","a"-"z","0"-"9","$","_"])* >
    | < INTEGER : (["0" - "9"])+ >
;

Start:
    (ImportDeclaration)* ClassDeclaration <EOF>
;

ImportDeclaration:
    < IMPORT > < ID >  (< DOT > < ID >)* < SEMICOLON >
;

ClassDeclaration:
    < CLASS > < ID > (< EXTENDS > < ID >)? < OPEN_CURLY_BRACKETS > (VarDeclaration | MethodDeclaration)* < CLOSE_CURLY_BRACKETS >
;

VarDeclaration:
    Type < ID > (< EQUAL > Expression)? < SEMICOLON >
;

MethodDeclaration:
    <PUBLIC> (MainMethod | RegularMethod)
;

RegularMethod:
    Type < ID > { jjtThis.put("name", lastConsumedToken.getImage()); } < OPEN_PARENTHESES > (Type < ID > { jjtThis.put("name", lastConsumedToken.getImage()); } (< COMMA > Type < ID > { jjtThis.put("name", lastConsumedToken.getImage()); })*)? < CLOSE_PARENTHESES >
    < OPEN_CURLY_BRACKETS >
        ( SCAN 2 VarDeclaration | Statement )*
        < RETURN > Expression < SEMICOLON >
    < CLOSE_CURLY_BRACKETS >
;

MainMethod:
    < STATIC > < VOID > < MAIN > < OPEN_PARENTHESES > < ID > < OPEN_SQUARE_BRACKETS > < CLOSE_SQUARE_BRACKETS > < ID > < CLOSE_PARENTHESES >
    < OPEN_CURLY_BRACKETS >
        ( SCAN 2 VarDeclaration | Statement )*
    < CLOSE_CURLY_BRACKETS >
;

Type:
    < INT > (< OPEN_SQUARE_BRACKETS > < CLOSE_SQUARE_BRACKETS >)?
    | < BOOLEAN >
    | < ID >
;

Statement #void:
    (SCAN 2
        < ID > (
                < EQUAL > Expression < SEMICOLON > #VariableAssignment
                | < OPEN_SQUARE_BRACKETS > Expression < CLOSE_SQUARE_BRACKETS > < EQUAL > Expression < SEMICOLON > #ArrayAssignment
               )
        | Expression < SEMICOLON >
    )
    | < IF > < OPEN_PARENTHESES > Expression < CLOSE_PARENTHESES > Statement < ELSE > Statement #If
    | < WHILE > <OPEN_PARENTHESES > Expression < CLOSE_PARENTHESES > Statement #While
    | < OPEN_CURLY_BRACKETS > (Statement)* < CLOSE_CURLY_BRACKETS >
;

Expression #void:
    OrExpression
;

OrExpression #void:
    AndExpression ((<OR> AndExpression { jjtThis.put("op", "or"); }) #BinOp(2))*
;

AndExpression #void:
    RelationalExpression ((<AND> RelationalExpression { jjtThis.put("op", "and"); }) #BinOp(2) )*
;

RelationalExpression #void:
    AddExpression ((<LESS_THAN> AddExpression { jjtThis.put("op", "lt"); }) #BinOp(2))?
;

AddExpression #void:
    MultExpression (
            (<PLUS> MultExpression { jjtThis.put("op", "add"); }) #BinOp(2)
            | (<MINUS> MultExpression { jjtThis.put("op", "sub"); }) #BinOp(2)
        )*
;

MultExpression #void:
    NewExpression (
            (<TIMES> NewExpression { jjtThis.put("op", "mul"); }) #BinOp(2)
            | (<DIVIDE> NewExpression { jjtThis.put("op", "div"); }) #BinOp(2)
        )*
;

NewExpression #void:
    < NEW > (
                < INT > < OPEN_SQUARE_BRACKETS > NotExpression < CLOSE_SQUARE_BRACKETS > #NewArray
                | < ID > < OPEN_PARENTHESES > < CLOSE_PARENTHESES > #NewObject
            )
    | NotExpression
;

NotExpression #void:
    (< NOT > TerminalExpression { jjtThis.put("op", "not"); }) #UnaryOp(1)
    | TerminalExpression
;

TerminalExpression #void:
    ((
        < OPEN_PARENTHESES > Expression < CLOSE_PARENTHESES >
        | Terminal
    ) (TerminalExpressionCompound)*) #CompoundExpression(>=2)
;

TerminalExpressionCompound #void:
    (< OPEN_SQUARE_BRACKETS > Expression < CLOSE_SQUARE_BRACKETS >) #Indexation
    | (< DOT > (< LENGTH > | < ID > { jjtThis.put("name", lastConsumedToken.getImage()); } < OPEN_PARENTHESES > (Expression (< COMMA > Expression)*)? < CLOSE_PARENTHESES >)) #MethodCall
;

Terminal #void:
    < TRUE > #True
    | < FALSE > #False
    | < THIS > #This
    | (< ID > { jjtThis.put("name", lastConsumedToken.getImage()); }) #Id
    | (< INTEGER > { jjtThis.put("value", lastConsumedToken.getImage()); }) #IntLiteral
;

// Injections for the implementation of JmmNode
// Since this is injected into BaseNode, it affects only non-terminals
INJECT BaseNode:
		import pt.up.fe.comp.jmm.ast.JmmNode;
		import pt.up.fe.comp.jmm.ast.AJmmNode;
		import pt.up.fe.specs.util.SpecsCollections;
		extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {
        return SpecsCollections.cast(children(), JmmNode.class);
    }

    @Override
    public void add(JmmNode child, int index) {
        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }
    }
}
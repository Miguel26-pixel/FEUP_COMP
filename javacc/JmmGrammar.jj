PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP :
    < SPACE : " " >
    | < TAB : "\t" >
    | < CARRIAGE_RETURN: "\r" >
    | < LINE_FEED: "\n" >
    | < SINGLE_LINE_COMMENT: "//" (~["\r", "\n"])* >
    | < MULTI_LINE_COMMENT: "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >
;

TOKEN :
	< PLUS : "+" >
	| < MINUS : "-" >
	| < TIMES : "*" >
	| < DIVIDE : "/" >
    | < EQUAL : "=" >
	| < AND: "&&" >
	| < OR: "||" >
	| < LESS_THAN: "<" >
	| < NOT: "!" >
	| < OPEN_PARENTHESES : "(" >
	| < CLOSE_PARENTHESES : ")" >
	| < OPEN_CURLY_BRACKETS : "{" >
    | < CLOSE_CURLY_BRACKETS : "}" >
	| < OPEN_SQUARE_BRACKETS : "[" >
    | < CLOSE_SQUARE_BRACKETS : "]" >
	| < SEMICOLON : ";" >
	| < DOT : "." >
	| < COMMA : "," >
	| < IMPORT : "import" >
    | < CLASS : "class" >
    | < EXTENDS : "extends" >
    | < PUBLIC : "public" >
    | < STATIC : "static" >
    | < VOID : "void" >
    | < MAIN : "main" >
    | < THIS : "this" >
    | < NEW : "new" >
    | < STRING : "String" >
    | < BOOLEAN : "boolean" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < INT : "int" >
    | < IF : "if" >
    | < ELSE : "else" >
    | < WHILE : "while" >
    | < LENGTH : "length" >
    | < RETURN : "return" >
    | < ID : ["A"-"Z","a"-"z","$","_"](["A"-"Z","a"-"z","0"-"9","$","_"])* >
    | < INTEGER : (["0" - "9"])+ >
;

Start:
    (ImportDeclaration)* ClassDeclaration <EOF>
;

ImportDeclaration:
    < IMPORT > < ID >  ( < DOT > < ID > )* < SEMICOLON >
;

ClassDeclaration:
    < CLASS > < ID > (< EXTENDS > < ID >)? < OPEN_CURLY_BRACKETS > (VarDeclaration | MethodDeclaration)* < CLOSE_CURLY_BRACKETS >
;

VarDeclaration:
    Type < ID > (< EQUAL > Expression)? < SEMICOLON >
;

MethodDeclaration:
    <PUBLIC> (MainMethod | RegularMethod)
;

RegularMethod:
    Type < ID > < OPEN_PARENTHESES > (Type < ID > (< COMMA > Type < ID >)*)? < CLOSE_PARENTHESES >
    < OPEN_CURLY_BRACKETS>
        ( SCAN 2 VarDeclaration | Statement )*
        < RETURN > Expression < SEMICOLON >
    < CLOSE_CURLY_BRACKETS >
;

MainMethod:
    < STATIC > < VOID > < MAIN > < OPEN_PARENTHESES > < STRING > < OPEN_SQUARE_BRACKETS > < CLOSE_SQUARE_BRACKETS > < ID > < CLOSE_PARENTHESES >
    < OPEN_CURLY_BRACKETS>
        ( SCAN 2 VarDeclaration | Statement)*
    < CLOSE_CURLY_BRACKETS >
;

Type:
    < INT > (< OPEN_SQUARE_BRACKETS > < CLOSE_SQUARE_BRACKETS >)?
    | < BOOLEAN >
    | < ID >
;

Statement:
    (SCAN 2
        < ID > (
                < EQUAL > Expression < SEMICOLON >
                | < OPEN_SQUARE_BRACKETS > Expression < CLOSE_SQUARE_BRACKETS > < EQUAL > Expression < SEMICOLON >
               )
        | Expression < SEMICOLON >
    )
    | < IF > < OPEN_PARENTHESES > Expression < CLOSE_PARENTHESES > Statement < ELSE > Statement
    | < WHILE > <OPEN_PARENTHESES > Expression < CLOSE_PARENTHESES > Statement
    | < OPEN_CURLY_BRACKETS > (Statement)* < CLOSE_CURLY_BRACKETS >
;

Expression:
    (
        < NEW > (
                    < INT > < OPEN_SQUARE_BRACKETS > Expression < CLOSE_SQUARE_BRACKETS >
                    | < ID > < OPEN_PARENTHESES > < CLOSE_PARENTHESES >
                )
        | < NOT > Expression
        | < OPEN_PARENTHESES > Expression < CLOSE_PARENTHESES >
        | Terminal
    ) (ExpressionCompound)*
;

ExpressionCompound:
    BinaryOperator Expression
    | < OPEN_SQUARE_BRACKETS > Expression < CLOSE_SQUARE_BRACKETS >
    | < DOT > (< LENGTH > | < ID > < OPEN_PARENTHESES > (Expression (< COMMA > Expression)*)? < CLOSE_PARENTHESES >)
;

Terminal:
    < INTEGER >
    | < TRUE >
    | < FALSE >
    | < ID >
    | < THIS >
;

BinaryOperator:
    < AND > | < LESS_THAN > | < PLUS > | < MINUS > | < TIMES > | < DIVIDE >
;

// simple expression
AdditiveExpression :
	MultiplicativeExpression
	(
		(< PLUS > | < MINUS >)
		MultiplicativeExpression
	)?
;

MultiplicativeExpression :
	Factor
	(
		(< TIMES > | < DIVIDE >)
		Factor
	)?
;

Factor :
	< INTEGER > |
	< MINUS> Factor |
	< OPEN_PARENTHESES > AdditiveExpression < CLOSE_PARENTHESES >
;
